+++
date = '2025-09-16T19:03:30+08:00'
draft = false
categories = ['算法笔记']
tags = ['二进制', '位运算']
title = '003 二进制和位运算'
+++

{{< katex >}}

## 数字如何用二进制表示

### 无符号数

所有二进制位作为数字位，通过二进制加法得到真实的值。

只能表示正数，范围为\([0, 2^n -1]\)，n 表示位数。

例如，四位二进制数表示 15 为 1111。

### 有符号数

二进制位的首位表示符号位，其中 0 表示正数，1 表示负数，其余为表示数字位。

#### 正数

对于四位二进制数，表示为 0xxx，范围为 \([0, 2 ^ {n - 1} - 1]\)

#### 负数

对于四位二进制数，表示为 1xxx，范围为 \([-2 ^ {n - 1}, -1]\)

+ 任意十进制负数转换为二进制有符号数 | -3：

    1. 写出其正数的二进制表示 | 0011
    2. 对该二进制数 - 1 | 0010
    3. 包括符号位在内，所有位取反 | 1101
    4. 最终得到了该负数的二进制表示 | 1101

+ 任意负的二进制有符号数转换为十进制负数 | 1101
    
    1. 看符号位确定是负数 | 1
    2. 包括符号位在内，所有位取反 | 0010
    3. 对该二进制数 + 1 | 0011
    4. 转换为对应的十进制整数取反 | -3

### 代码中表示二进制数

+ 0b 开头表示后面的数字是二进制表示
``` cpp
int b7 = 0b00000000000000000000000000000111;
```

+ 0x 开头表示后面的数字是十六进制表示
```cpp
int x7 = 0x00000007;
```

### 为什么负数的二进制数这么设计

这种设计保证了减法和加法运算一致

比如 3 - 5 = -2 ，可以视作 3 + (-5) = 0011 + 1001 = 1100 = -2

### 小心溢出

对于整数相关的数据结构，其底层的二进制数的位数是固定的，比如 int 是 32 位，long 是 64 位。当运算发生溢出时，计算机不会对溢出做处理，可能导致错误的结果。

## 位运算

### 取反 ~

取反运算是对二进制数的每一数位取相反的值，0变1，1变0

~0001 = 1110

#### 取相反数

取一个数的相反数，除了 -num，还可以 取反 + 1

7 的相反数 -7 = ~7 + 1 = ~0111 + 1 = 1001

利用上面讲过的负二进制有符号数转换为十进制负数的方法，可知 1001 为 -7

注意，负数的最小值 \(-2^{n - 1}\) 取相反数，仍然是自身

对于 4 为的二进制表示中，最大的负数是 1000，即 -8，~1000 + 1 = 1000

### 位运算或 | 位运算与 & 异或 ^

运算的结果是二进制数

### 逻辑或 || 逻辑与 &&

运算的结果是 bool，当能确定表达式的值时，不会算右操作数，又称作短路运算符

### 移位运算

#### 算数左移 逻辑左移 逻辑右移

+ 算数左移 x << i : 将 x 的二进制数向左移动 i 位，右侧补 0
+ 逻辑左移 x <<< i : 将 x 的二进制数向左移动 i 位，右侧补 0，行为与算术左移一致
+ 逻辑右移 x >>> i : 将 x 的二进制数向右移动 i 位，左侧补 0

#### 算数右移

x >> i : 将 x 的二进制数向右移动 i 位，左侧补 符号位上的数

#### 非负数数值变化

+ 左移 i 位相当于 乘 \(2^i\)
+ 右移 i 位相当于 除 \(2^i\)

注意，对于负数，没有此规律

### 打印 数的二进制表示

对于 32 位的 int
```cpp
void printBinary(int num) {
    for (int i = 31; i >= 0; i--) {
        cout << ((num & (1 << i)) == 1 ? '1' : '0');
    }
    cout << "\n";
}
```